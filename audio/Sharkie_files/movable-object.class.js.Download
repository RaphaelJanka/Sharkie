class MovableObject extends DrawableObject {
    speed = 0.15;
    otherDirection = false;
    rotation = 0;
    energy = 100;
    lastHit = 0;
    speedY = 0;
    collectedCoins = 0;
    collectedBottles = 0;
    usedBottles = 0;
    acceleration = 1
    isAttacking = false;

    isColliding(mo) {
        if (this instanceof Character) {
            return this.x + 60 + this.width - 105 >= mo.x &&
                this.x + 60 <= mo.x + mo.width &&
                this.y + 130 + this.height - 190 > mo.y &&
                this.y + 130 <= mo.y + mo.height
        } else if (this instanceof Endboss) {
            return this.x + 40 + this.width - 100 >= mo.x &&
                this.x + 40 <= mo.x + mo.width &&
                this.y + this.height > mo.y &&
                this.y <= mo.y + mo.height
        } else if (this instanceof PufferFishOrange || this instanceof PufferFishGreen || this instanceof PufferFishDeadly) {
            return this.x + 40 + this.width -50 >= mo.x &&
                this.x + 40 <= mo.x + mo.width &&
                this.y + 80 + this.height - 200 > mo.y &&
                this.y + 80 <= mo.y + mo.height
        } else {
            return this.x + this.width >= mo.x &&
                this.x <= mo.x + mo.width &&
                this.y + this.height > mo.y &&
                this.y <= mo.y + mo.height
        }
    }
    playSwimmingAnimation(images) {
        let i = this.currentImage % images.length;
        let path = images[i];
        this.img = this.imageCache[path];
        this.currentImage++;
    }
    playDeathAnimation(images) {
        let i = this.currentImage % images.length;
        let path = images[i];
        this.img = this.imageCache[path];
        
        if (i === images.length - 1) {
            this.currentImage = images.length - 1;
        } else {
            this.currentImage++;
        }
    }
    
    playFightingBubbleAnimation(images) {
        let i = this.currentImage % images.length;
        let path = images[i];
        this.img = this.imageCache[path];
        this.currentImage++;
    }

    moveRight() {
        setInterval(() => {
            this.speed = 0.6;
            this.x += this.speed;
        }, 1000 / 60)
    }

    moveLeft() {
        setInterval( () => {
            this.x -= this.speed;
        }, 1000 / 60)
    }
   
   
    moveBubblesToRight() {
        setInterval(() => {
            this.speed = 7;
            this.speedY = 1;
            this.x += this.speed;
            this.y -= this.speedY + this.acceleration;
        }, 1000/ 60);
    }

    moveBubblesToLeft() {
        setInterval(() => {
            this.speed = 7;
            this.speedY = 1;
            this.x -= this.speed;
            this.y -= this.speedY + this.acceleration;
        }, 1000/ 60);
    }

    moveUp() {
        setInterval( () => {
            this.y -= this.speed;
        }, 1000 / 60)
    }

    hit() {
        this.energy -= 10;
        if (this.energy < 0) {
            this.energy = 0;
        } else {
            this.lastHit = new Date().getTime();
        }
    }
    hitByBoss() {
        this.energy -= 50;
        if (this.energy < 0) {
            this.energy = 0;
        } else {
            this.lastHit = new Date().getTime();
        }
    }

    hitEnemy() {
        this.energy -= 100;
        if (this.energy < 0) {
            this.energy = 0;
        } else {
            this.lastHit = new Date().getTime();
        }
    }

    hitEndboss() {
        this.energy -= 25;
        if (this.energy < 0) {
            this.energy = 0;
        } else {
            this.lastHit = new Date().getTime();
        }
    }

    isHurt() {
        let timepassed = new Date().getTime() - this.lastHit; // Difference in ms
        timepassed = timepassed / 1000; // Difference in s
        return timepassed < 1;
    }

    isDead() {
        return this.energy == 0;
    }
    
    isAttackingCharacter() {
        return this.isAttacking = true;
    }
    moveToSurfaceWhenDead() {
        this.speed = 0;
        this.speedY = 2;
        this.y -= this.speedY;
    }
    moveEnemyUpToSurfaceWhenDead() {
        this.speed = 0;
        this.speedY = 15;
        this.y -= this.speedY;
    }
    isCollectingCoins() {
        return this.collectedCoins += 10;
    }
    isCollectingBottle() {
        return this.collectedBottles += 20;
    }
    isUsingBottles() {
        return this.collectedBottles -= 20;
    }

    

    playAudioJellyfishes(audio, soundPlayed) { 
        if (sound) {
            audio.play;
            soundPlayed = true;
        }
    }


}

/*
_________________________________________________________________________________________________
                
                Die Methode loadImages(arr) erwartet als Argument ein Array von Bildpfaden (arr), 
                die geladen und im Cache gespeichert werden sollen.

                Mit arr.forEach(path => { ... }) wird eine Schleife gestartet, die über jedes Element im Array arr iteriert. 
                In diesem Fall repräsentiert jedes path einen Bildpfad in Form einer Zeichenkette (String).

                Innerhalb der Schleife wird für jeden Bildpfad ein neues Image-Objekt erstellt. 
                let img = new Image(); erzeugt eine Instanz eines HTML Image-Objekts, das dazu verwendet wird, Bilder im Browser zu laden.

                img.src = path; setzt den src (Quellpfad) des Image-Objekts auf den Wert des aktuellen Bildpfads path. 
                Dadurch wird der Browser angewiesen, das Bild von diesem Pfad zu laden.

                
                
                this.imageCache[path] = img;

                In diesem Schritt wird das Image-Objekt (img), das das geladene Bild repräsentiert, im imageCache-Objekt gespeichert. 
                Dabei wird der Pfad (path) als Schlüssel verwendet, und das Image-Objekt wird als Wert zugewiesen. 
                Das ermöglicht den späteren Zugriff auf das bereits geladene Bild über den imageCache.


*/
